---
description: Project coding guidelines for FastAPI (Python) and Next.js (TypeScript)
globs: ["backend/**/*.py", "frontend/**/*.{ts,tsx}"]
alwaysApply: true
---

# Python / FastAPI Guidelines

## Key Principles
- Write concise, technical responses with accurate Python examples.
- Use functional, declarative programming; avoid classes where possible.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission).
- Use lowercase with underscores for directories and files (e.g., routers/user_routes.py).
- Favor named exports for routes and utility functions.
- Use the Receive an Object, Return an Object (RORO) pattern.

## Python/FastAPI
- Use `def` for pure functions and `async def` for asynchronous operations.
- Use type hints for all function signatures. Prefer Pydantic models over raw dictionaries.
- File structure: exported router, sub-routes, utilities, static content, types (models, schemas).
- Avoid unnecessary curly braces in conditionals.
- For single-line statements in conditionals, omit curly braces.
- Use concise one-line syntax for simple conditionals (`if condition: do_something()`).

## Error Handling & Validation
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions; avoid deep nesting.
- Place the happy path last in the function.
- Avoid unnecessary `else` blocks; prefer `if-return`.
- Use guard clauses for preconditions and invalid states.
- Implement proper error logging and user-friendly messages.
- Use custom error types or factories for consistency.

## Dependencies
- FastAPI
- Pydantic v2
- Async database libraries (asyncpg, aiomysql)
- SQLAlchemy 2.0 (if using ORM)

## FastAPI-Specific
- Use functional components and Pydantic models for input/output.
- Prefer lifespan context managers over `@app.on_event`.
- Use middleware for logging, error monitoring, and performance.
- Optimize for async I/O, caching, and lazy loading.
- Use `HTTPException` for expected errors; model responses explicitly.

## Performance
- Avoid blocking I/O; always use async for DB/API calls.
- Implement caching (Redis, in-memory).
- Optimize serialization/deserialization with Pydantic.
- Use lazy loading for large datasets.

---

# Next.js / TypeScript Guidelines

## Code Style & Structure
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming; avoid classes.
- Prefer iteration and modularization over duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure: exported component, subcomponents, helpers, static, types.

## Naming Conventions
- Use lowercase with dashes for directories (e.g., `components/auth-wizard`).
- Favor named exports for components.

## TypeScript Usage
- Use interfaces over types where possible.
- Avoid enums; use maps instead.
- Use functional components with interfaces.
- Prefer `function` keyword for pure functions.

## Syntax & Formatting
- Use concise conditionals; omit unnecessary braces.
- Write declarative JSX.

## UI & Styling
- Use Shadcn UI, Radix, and Tailwind for components.
- Implement responsive design with Tailwind (mobile-first).
- Use soft shadows, rounded corners, adequate padding.

## Performance
- Minimize `use client`, `useEffect`, and `setState`; favor RSC.
- Wrap client components in `Suspense` with fallback.
- Use dynamic imports for non-critical components.
- Optimize images (WebP, lazy load, include size data).

## Conventions
- Use `nuqs` for URL state management.
- Optimize Core Web Vitals (LCP, CLS, FID).
- Use SSR/Server Components for data fetching where possible.
- Use `use client` only when absolutely necessary.
